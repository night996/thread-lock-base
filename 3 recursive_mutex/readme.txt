recursive_mutex会减少死锁几率？恩看上去的确如此，但是事实上呢？我们从BOOST的官方逻辑去理解：

recursive_mutex类可多次进入锁，这样在递归时可以避免一次死锁的几率，这是原本BOOST中所体现的一种思想，OK，为什么我们要质疑其问题。

最近项目中大量使用recursive_mutex锁作为主力锁，但是奇迹般的发现，一个递归函数仍然存在死锁（已做优化，换为mutex没问题），一个CALL BACK也存在死锁，OK我们的问题来了，我们其实无法使用更好的方式去排错，因为你不知道是哪个锁引起的，递归锁可多次锁，同样的需要多次解锁，那么问题就来了，如果真正或可能造成这次死锁的位置在某个已经进入死锁的地方，那么死锁的位置可能并不是你需要的位置，简单的说，如果A锁了3次，B锁一次，C锁一次，这样就锁出现死锁，排错之困难可想而知。

那么从这点来看，其实recursive_mutex在使用时，我们必须特别注意使用的方式和方法，否则排错将成为你一直需要做的事情，太可怕了。

而且recursive_mutex并不利于代码的优化，因为递归锁存在效率低下的问题，所以必须谨慎谨慎。